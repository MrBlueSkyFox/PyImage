import os
import sys
import cv2
import time
import numpy as np
from argparse import ArgumentParser, SUPPRESS
from imutils.video import VideoStream
from imutils.video import FPS
import imutils
import logging as log
from detector import Detector

from openvino.inference_engine import IECore


sys.path.append(os.path.join(os.path.dirname(
    os.path.dirname(os.path.abspath(__file__))), 'common'))


def build_argparser():
    parser = ArgumentParser(add_help=False)
    args = parser.add_argument_group('Options')
    args.add_argument("-m", "--model", help="Required. Path to an .xml file with a trained model.",
                      required=False, type=str)
    args.add_argument("-i", "--input", type=str, nargs='+',
                      default='', help="path to video or image/images")
    args.add_argument("-d", "--device",
                      help="Optional. Specify the target device to infer on; CPU, GPU, FPGA, HDDL or MYRIAD is "
                           "acceptable. The demo will look for a suitable plugin for device specified. "
                           "Default value is CPU", default="CPU", type=str)
    args.add_argument("-pt", "--prob_threshold", help="Optional. Probability threshold for detections filtering",
                      default=0.5, type=float)
    args.add_argument("-t", "--tracker", type=str,
                      default="kcf", help="OpenCV object tracker type")
    args.add_argument(
        "--no_show", help="Optional. Don't show output", action='store_true')

    return parser


class ImageReader(object):
    def __init__(self, file_names):
        self.file_names = file_names
        self.max_idx = len(file_names)

    def __iter__(self):
        self.idx = 0
        return self

    def __next__(self):
        if self.idx == self.max_idx:
            raise StopIteration
        img = cv2.imread(self.file_names[self.idx], cv2.IMREAD_COLOR)
        if img.size == 0:
            raise IOError('Image {} cannot be read'.format(
                self.file_names[self.idx]))
        self.idx += 1
        return img


class VideoReader(object):
    def __init__(self, file_name):
        try:
            self.file_name = int(file_name[0])
        except:
            self.file_name = file_name[0]

    def __iter__(self):
        self.cap = cv2.VideoCapture(self.file_name)
        if not self.cap.isOpened():
            raise IOError('Video {} cannot be opened'.format(self.file_name))
        return self

    def __next__(self):
        was_read, img = self.cap.read()
        if not was_read:
            raise StopIteration
        return img


def main():
    log.basicConfig(format="[ %(levelname)s ] %(message)s",
                    level=log.INFO, stream=sys.stdout)

    args = build_argparser().parse_args()
    log.info("Loading Inference Engine")
    # --------------------------- 1. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
    ie = IECore()
    detector = Detector(ie, args.model, args.device, args.prob_threshold)

    img = cv2.imread(args.input[0], cv2.IMREAD_COLOR)
    frames_reader, delay = (VideoReader(args.input), 1) if img is None else (
        ImageReader(args.input), 0)
    il = 0
    for frame in frames_reader:
        detections = detector.detect(frame)
        if il >= 1:
            # il += 1
            break
        il += 1
        # print(detections)


if __name__ == "__main__":
    sys.exit(main() or 0)
